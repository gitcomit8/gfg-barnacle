<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 17: Shadowed Canvas Context Bug Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        h1 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .warning strong {
            color: #856404;
        }
        
        .demo-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .canvas-container {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9fa;
        }
        
        canvas {
            width: 100%;
            height: 300px;
            border-radius: 4px;
            background: black;
            display: block;
        }
        
        .controls {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-warning:hover {
            background: #e0a800;
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }
        
        .bug-indicator {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }
        
        .bug-indicator.active {
            display: block;
        }
        
        .instructions {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .log {
            background: #263238;
            color: #aed581;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .log-entry {
            margin: 2px 0;
        }
        
        .log-entry.cache-hit {
            color: #ff9800;
        }
        
        .log-entry.cache-miss {
            color: #4caf50;
        }
        
        .log-entry.bug {
            color: #f44336;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêõ Module 17: The Shadowed Canvas Context</h1>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Educational Bug Demo</strong><br>
            This module demonstrates a WebGL state caching bug that causes non-deterministic rendering glitches.
            The bug occurs when JavaScript modifies the GL context between WASM calls.
        </div>
        
        <div class="instructions">
            <strong>üìã How to Trigger the Bug:</strong>
            <ol>
                <li>Click <code>Apply Grayscale</code> - should work correctly</li>
                <li>Click <code>Render UI Overlay (JS)</code> - this modifies GL state</li>
                <li>Click <code>Apply Grayscale</code> again - <strong>GLITCH!</strong> üêû</li>
                <li>Check console for "Cache hit: skipping bind" messages</li>
            </ol>
            <p><strong>Expected:</strong> Grayscale filter should work consistently<br>
            <strong>Actual:</strong> After JS GL operations, WASM uses stale cache ‚Üí visual glitches</p>
        </div>
        
        <div class="demo-area">
            <div class="canvas-container">
                <h3>Main Canvas</h3>
                <canvas id="mainCanvas" width="400" height="300"></canvas>
            </div>
            <div class="canvas-container">
                <h3>Reference (No Bug)</h3>
                <canvas id="referenceCanvas" width="400" height="300"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <h3>WASM Image Processing (Buggy)</h3>
            <div class="button-group">
                <button class="btn-primary" onclick="applyGrayscale()">Apply Grayscale</button>
                <button class="btn-primary" onclick="applyBlur()">Apply Blur</button>
                <button class="btn-primary" onclick="applyInvert()">Apply Invert</button>
                <button class="btn-success" onclick="resetCanvas()">Reset Canvas</button>
            </div>
            
            <h3>JavaScript GL Operations (Triggers Bug)</h3>
            <div class="button-group">
                <button class="btn-warning" onclick="renderJSOverlay()">Render UI Overlay (JS)</button>
                <button class="btn-warning" onclick="drawJSRectangle()">Draw JS Rectangle</button>
                <button class="btn-danger" onclick="invalidateCache()">Invalidate Cache (Fix)</button>
            </div>
        </div>
        
        <div class="bug-indicator" id="bugIndicator">
            <strong>üêû BUG LIKELY TRIGGERED!</strong><br>
            JavaScript has modified the GL state. The next WASM call will likely produce a glitch
            because the Rust cache is now stale.
        </div>
        
        <div class="status">
            <strong>Status:</strong> <span id="statusText">Initialized</span><br>
            <strong>Frame Count:</strong> <span id="frameCount">0</span><br>
            <strong>Last Operation:</strong> <span id="lastOp">None</span>
        </div>
        
        <div class="log" id="logContainer">
            <div class="log-entry">Console log will appear here...</div>
        </div>
    </div>
    
    <script type="module">
        import init, { ImageProcessor, get_webgl_context } from './pkg/shadowed_canvas_context.js';
        
        let processor = null;
        let gl = null;
        let jsGl = null;
        let glStateModified = false;
        
        // Initialize the module
        async function initModule() {
            try {
                await init();
                
                // Get WebGL context for main canvas (WASM will use this)
                gl = get_webgl_context('mainCanvas');
                processor = new ImageProcessor(gl);
                
                // Get context for reference canvas (pure JS)
                const refCanvas = document.getElementById('referenceCanvas');
                jsGl = refCanvas.getContext('webgl');
                
                // Draw initial test pattern
                drawTestPattern();
                
                updateStatus('Ready', 'Initialization complete');
                addLog('‚úì Module initialized successfully');
            } catch (err) {
                console.error('Initialization error:', err);
                updateStatus('Error', err.toString());
                addLog('‚úó Initialization failed: ' + err.toString(), 'bug');
            }
        }
        
        function drawTestPattern() {
            // Draw colorful test pattern on main canvas
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#FF6B6B');
            gradient.addColorStop(0.5, '#4ECDC4');
            gradient.addColorStop(1, '#45B7D1');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some shapes
            ctx.fillStyle = '#FFE66D';
            ctx.fillRect(50, 50, 100, 100);
            
            ctx.fillStyle = '#FF6B9D';
            ctx.beginPath();
            ctx.arc(300, 150, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#C44569';
            ctx.fillRect(150, 180, 120, 80);
            
            // Copy to reference canvas
            const refCanvas = document.getElementById('referenceCanvas');
            const refCtx = refCanvas.getContext('2d');
            refCtx.drawImage(canvas, 0, 0);
        }
        
        function updateStatus(status, operation) {
            document.getElementById('statusText').textContent = status;
            document.getElementById('lastOp').textContent = operation;
            if (processor) {
                document.getElementById('frameCount').textContent = processor.get_frame_count();
            }
        }
        
        function addLog(message, type = '') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 20 entries
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }
        
        // Override console.log to capture WASM logs
        const originalLog = console.log;
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.join(' ');
            if (message.includes('Cache hit')) {
                addLog(message, 'cache-hit');
            } else if (message.includes('Cache miss')) {
                addLog(message, 'cache-miss');
            } else if (message.includes('BUG') || message.includes('bug')) {
                addLog(message, 'bug');
            }
        };
        
        window.applyGrayscale = function() {
            try {
                processor.apply_grayscale();
                updateStatus('Success', 'Grayscale filter applied');
                addLog('Applied grayscale filter');
                
                if (glStateModified) {
                    addLog('‚ö†Ô∏è GL state was modified by JS - potential bug!', 'bug');
                    document.getElementById('bugIndicator').classList.add('active');
                }
                
                glStateModified = false;
            } catch (err) {
                updateStatus('Error', err.toString());
                addLog('Error: ' + err.toString(), 'bug');
            }
        };
        
        window.applyBlur = function() {
            try {
                const canvas = document.getElementById('mainCanvas');
                processor.apply_blur(canvas.width, canvas.height);
                updateStatus('Success', 'Blur filter applied');
                addLog('Applied blur filter');
                
                if (glStateModified) {
                    addLog('‚ö†Ô∏è GL state was modified by JS - potential bug!', 'bug');
                    document.getElementById('bugIndicator').classList.add('active');
                }
                
                glStateModified = false;
            } catch (err) {
                updateStatus('Error', err.toString());
                addLog('Error: ' + err.toString(), 'bug');
            }
        };
        
        window.applyInvert = function() {
            try {
                processor.apply_invert();
                updateStatus('Success', 'Invert filter applied');
                addLog('Applied invert filter');
                
                if (glStateModified) {
                    addLog('‚ö†Ô∏è GL state was modified by JS - potential bug!', 'bug');
                    document.getElementById('bugIndicator').classList.add('active');
                }
                
                glStateModified = false;
            } catch (err) {
                updateStatus('Error', err.toString());
                addLog('Error: ' + err.toString(), 'bug');
            }
        };
        
        window.renderJSOverlay = function() {
            // This modifies the GL context state, invalidating WASM's cache
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            
            // Draw a semi-transparent overlay
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.font = '24px Arial';
            ctx.fillText('JS Overlay', 120, 150);
            
            glStateModified = true;
            updateStatus('Warning', 'JS modified GL state - WASM cache is now stale!');
            addLog('üî¥ JavaScript modified GL context', 'bug');
            document.getElementById('bugIndicator').classList.add('active');
        };
        
        window.drawJSRectangle = function() {
            // Another JS operation that modifies GL state
            const canvas = document.getElementById('mainCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.fillRect(
                Math.random() * (canvas.width - 100),
                Math.random() * (canvas.height - 100),
                100,
                100
            );
            
            glStateModified = true;
            updateStatus('Warning', 'JS drew rectangle - WASM cache is stale!');
            addLog('üî¥ JavaScript drew on canvas', 'bug');
            document.getElementById('bugIndicator').classList.add('active');
        };
        
        window.resetCanvas = function() {
            drawTestPattern();
            processor.clear();
            glStateModified = false;
            updateStatus('Reset', 'Canvas cleared');
            addLog('Canvas reset to initial state');
            document.getElementById('bugIndicator').classList.remove('active');
        };
        
        window.invalidateCache = function() {
            // This is the "fix" - manually invalidate the cache
            processor.invalidate_cache();
            glStateModified = false;
            updateStatus('Fixed', 'Cache invalidated');
            addLog('‚úì Cache manually invalidated (bug workaround)', 'cache-miss');
            document.getElementById('bugIndicator').classList.remove('active');
        };
        
        // Initialize on load
        initModule();
    </script>
</body>
</html>
